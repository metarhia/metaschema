{
  domain: { domain: 'Nomen' },
  category: { domain: 'Nomen' },
  required: { domain: 'Logical' },
  unique: { domain: 'Logical' }, // single field unique key
  index: { domain: 'Logical' }, // single field index
  default: { domain: 'Nomen' }, // default value to be casted to domain
  example: { domain: 'Nomen' },
  display: { domain: 'Logical' }, // true if lookup result
  control: { domain: 'Nomen' }, // GUI visual control name
  validate: { domain: 'Lambda' }, // (value) => (Boolean)
  expression: { domain: 'Lambda' }, // (record) = > (value)
  comment: { domain: 'Text' },

  Check: Validate(data => {
    const isDomain = !!data.domain;
    const isCategory = !!data.category;

    // Required just one of fields: domain or category
    if (isDomain && isCategory) return false;
    if (!isDomain && !isCategory) return false;

    const fields = Object.keys(data);

    // Check allowed fields
    const allow = allowed => {
      for (const field of fields) {
        if (!allowed.includes(field)) return false;
      }
      return true;
    };

    // Validate calculated field
    if (data.expression) {
      return allowed(['domain', 'display', 'category', 'control', 'comment']);
    }

    const decorator = data.constructor.name;

    // Check Include() decorator
    if (decorator === 'Include') {
      const all = allowed(['category', 'comment']);
      if (!all) return false;
    }

    // Check Master() decorator
    if (decorator === 'Master') {
      const all = allowed(['category', 'control', 'comment']);
      if (!all) return false;
    }

    // Check Many() decorator
    if (decorator === 'Many') {
      const all = allowed(['category', 'comment']);
      if (!all) return false;
    }

    // Check category fields
    if (isCategory) {
      const all = allowed(
        ['category', 'display', 'required', 'control', 'comment']
      );
      if (!all) return false;
    }

    // Check index definition
    return +data.index + +data.unique < 2;
  })
}
